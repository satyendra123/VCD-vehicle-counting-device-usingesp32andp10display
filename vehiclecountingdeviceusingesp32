#EXAMPLE-1 it send the AA 01 80 A0 high_byte Low_byte 55. and send this protocol to the arduino. arduino will receive it and calculate the vacancy and display the data.
from machine import Pin, UART
from time import sleep, ticks_ms
import esp32

# Configuration
entryLoopPin = 5  # Entry loop detector pin
exitLoopPin = 4   # Exit loop detector pin
totalParkingSlots = 500  # Increased to accommodate values like 495
uart_tx_pin = 16
uart_rx_pin = 17
debounceDelay = 50  # Debounce delay in milliseconds

# Initialize NVS for storing the vacantSlots value
nvs = esp32.NVS('storage')

# Try to get the 'vacantSlots' value from NVS, otherwise initialize it
try:
    vacantSlots = nvs.get_i32('vacantSlots')
except OSError:
    vacantSlots = totalParkingSlots
    nvs.set_i32('vacantSlots', vacantSlots)

# Set up entry and exit loop detectors
entryLoop = Pin(entryLoopPin, Pin.IN, Pin.PULL_UP)
exitLoop = Pin(exitLoopPin, Pin.IN, Pin.PULL_UP)

# Initialize UART
uart = UART(2, baudrate=9600, tx=uart_tx_pin, rx=uart_rx_pin)

def sendAvailableSlots(slots):
    # Split the slots value into two bytes
    high_byte = (slots >> 8) & 0xFF
    low_byte = slots & 0xFF
    # Create the protocol message as an array of bytes
    message = bytearray([0xAA, 0x01, 0x80, 0xA0, high_byte, low_byte, 0x55])
    uart.write(message)

def printAvailableSlots():
    print("Available Parking Slots:", vacantSlots)

# Print initial available slots
printAvailableSlots()
sendAvailableSlots(vacantSlots)

lastEntryTime = 0
lastExitTime = 0

# Main loop
while True:
    currentTime = ticks_ms()
    
    entryReading = entryLoop.value()
    exitReading = exitLoop.value()
    
    # Handle entry detection
    if entryReading == 0 and (currentTime - lastEntryTime >= debounceDelay):
        # Debouncing: Ensure the reading is stable
        sleep(0.05)
        if entryLoop.value() == 0:
            lastEntryTime = currentTime
            if vacantSlots > 0:
                vacantSlots -= 1
                printAvailableSlots()
                sendAvailableSlots(vacantSlots)
                nvs.set_i32('vacantSlots', vacantSlots)
                sleep(1)  # Delay to avoid rapid changes due to loop execution speed
    
    # Handle exit detection
    if exitReading == 0 and (currentTime - lastExitTime >= debounceDelay):
        # Debouncing: Ensure the reading is stable
        sleep(0.05)
        if exitLoop.value() == 0:
            lastExitTime = currentTime
            if vacantSlots < totalParkingSlots:
                vacantSlots += 1
                printAvailableSlots()
                sendAvailableSlots(vacantSlots)
                nvs.set_i32('vacantSlots', vacantSlots)
                sleep(1)  # Delay to avoid rapid changes due to loop execution speed   
    sleep(0.01)  # Small delay to reduce CPU usage

#EXAMPLE-2 the first one is working fine. but i want that i can set the totalParkingSlots using the protocol to make it dynamic. S900800 means the 900 tells the totalSlots and the 800 tells the vacantSlots.aur to agar humne starting me bydefault ye totalSlots ko 999 lega aur vacantSlots bhi 999 lega
#aur hum protocol ke through in dono values totalSlots and vacantSlots ko dynamically set kar sakte hai. S900800 ascii protocol send by the docklight software.
from machine import Pin, UART
from time import sleep, ticks_ms
import esp32

# Configuration
entryLoopPin = 5  # Entry loop detector pin
exitLoopPin = 4   # Exit loop detector pin
uart_tx_pin = 16
uart_rx_pin = 17
debounceDelay = 50  # Debounce delay in milliseconds

# Initialize NVS for storing the vacantSlots and totalParkingSlots values
nvs = esp32.NVS('storage')

# Try to get the 'totalParkingSlots' value from NVS, otherwise initialize it to a default value
try:
    totalSlots = nvs.get_i32('totalSlots')
except OSError:
    totalSlots = 999  # Default total parking slots
    nvs.set_i32('totalSlots', totalSlots)

# Try to get the 'vacantSlots' value from NVS, otherwise initialize it to the total parking slots
try:
    vacantSlots = nvs.get_i32('vacantSlots')
except OSError:
    vacantSlots = totalSlots
    nvs.set_i32('vacantSlots', vacantSlots)

# Set up entry and exit loop detectors
entryLoop = Pin(entryLoopPin, Pin.IN, Pin.PULL_UP)
exitLoop = Pin(exitLoopPin, Pin.IN, Pin.PULL_UP)

# Initialize UART
uart = UART(2, baudrate=9600, tx=uart_tx_pin, rx=uart_rx_pin)

def sendAvailableSlots(total, slots):
    # Split the total and slots values into two bytes each
    slots_high_byte = (slots >> 8) & 0xFF
    slots_low_byte = slots & 0xFF
    # Create the protocol message as an array of bytes
    message = bytearray([0xAA, 0x01, 0x80, 0xA0,slots_high_byte, slots_low_byte, 0x55])
    uart.write(message)

def printAvailableSlots():
    print("Available Parking Slots:", vacantSlots)

def printTotalSlots():
    print("Total Parking Slots:", totalSlots)

# Print initial available slots
printAvailableSlots()
printTotalSlots()
sendAvailableSlots(totalSlots, vacantSlots)

lastEntryTime = 0
lastExitTime = 0

# Main loop
while True:
    currentTime = ticks_ms()
    
    entryReading = entryLoop.value()
    exitReading = exitLoop.value()
    
    # Handle entry detection
    if entryReading == 0 and (currentTime - lastEntryTime >= debounceDelay):
        # Debouncing: Ensure the reading is stable
        sleep(0.05)
        if entryLoop.value() == 0:
            lastEntryTime = currentTime
            if vacantSlots > 0:
                vacantSlots -= 1
                printAvailableSlots()
                sendAvailableSlots(totalSlots, vacantSlots)
                nvs.set_i32('vacantSlots', vacantSlots)
                sleep(1)  # Delay to avoid rapid changes due to loop execution speed
    
    # Handle exit detection
    if exitReading == 0 and (currentTime - lastExitTime >= debounceDelay):
        # Debouncing: Ensure the reading is stable
        sleep(0.05)
        if exitLoop.value() == 0:
            lastExitTime = currentTime
            if vacantSlots < totalSlots:
                vacantSlots += 1
                printAvailableSlots()
                sendAvailableSlots(totalSlots, vacantSlots)
                nvs.set_i32('vacantSlots', vacantSlots)
                sleep(1)  # Delay to avoid rapid changes due to loop execution speed
    
    # Check if data is available on UART
    if uart.any():
        command = uart.read(1)
        if command == b'S':
            # Expecting the format 'S<total_slots><vacant_slots>', e.g., 'S500400' it sends the ascii data
            total_string = uart.read(3)
            vacant_string = uart.read(3)
            try:
                total = int(total_string)
                vacant = int(vacant_string)
                if total > 0 and 0 <= vacant <= total:
                    totalSlots = total
                    vacantSlots = vacant
                    nvs.set_i32('totalSlots', totalSlots)
                    nvs.set_i32('vacantSlots', vacantSlots)
                    print("Total Parking Slots set to:", totalSlots)
                    print("Available Parking Slots set to:", vacantSlots)
                    sendAvailableSlots(totalSlots, vacantSlots)
            except ValueError:
                pass  # Ignore if conversion to integer fails
    
    sleep(0.01)  # Small delay to reduce CPU usage


#NOTE- actually in the both the above code when i run this in the site then it stop working after 3-4 days. actually i think the issue is memory. because in every entry and exit of the car it stores the data into the memory
so it keeps feeling the memory which creates the issue i think. so to resolve this issue what would i do is i will update the data into the filesystem instead of using the memory

from machine import Pin, UART
from time import sleep, ticks_ms, ticks_diff
import littlefs

# Configuration
entryLoopPin = 5  # Entry loop detector pin
exitLoopPin = 4   # Exit loop detector pin
debounceDelay = 50  # Debounce delay in milliseconds

# Initialize and mount LittleFS
fs = littlefs.LittleFS()
fs.mount()

# Read data from LittleFS
try:
    with fs.open('storage.txt', 'r') as f:
        totalSlots = int(f.readline().strip())
        vacantSlots = int(f.readline().strip())
        totalEntry = int(f.readline().strip())
        totalExit = int(f.readline().strip())
        print("Data retrieved from LittleFS")
except Exception:
    totalSlots = 99  # Default total parking slots
    vacantSlots = totalSlots
    totalEntry = 0
    totalExit = 0
    print("Data initialized to default")

# Function to save data to LittleFS
def save_data():
    with fs.open('storage.txt', 'w') as f:
        f.write(f"{totalSlots}\n")
        f.write(f"{vacantSlots}\n")
        f.write(f"{totalEntry}\n")
        f.write(f"{totalExit}\n")
    print("Data written to LittleFS")

# Initialize UART
uart = UART(2, baudrate=9600, tx=Pin(17), rx=Pin(16))
uart2 = UART(1, baudrate=9600, tx=Pin(33), rx=Pin(32))

def sendAvailableSlots(slots):
    slots_str = f'{slots:02d}'
    message = f'|C|1|4|1|28-0-#u{slots_str}|'
    print(f"Sending message: {message}")  # Debug print
    uart.write(message.encode('ascii'))  # Ensure the message is encoded as ASCII

def sendNewUARTData(totalSlots, vacantSlots, totalEntry, totalExit):
    data_array = [0xAA, totalSlots, vacantSlots, totalEntry, totalExit, 0xCC]
    uart2.write(bytearray(data_array))
    print(f"New UART Data Sent: {data_array}")

def printAvailableSlots():
    print("Available Parking Slots:", vacantSlots)

def printTotalSlots():
    print("Total Parking Slots:", totalSlots)

# Print initial available slots
printAvailableSlots()
printTotalSlots()
sendAvailableSlots(vacantSlots)

lastEntryTime = 0
lastExitTime = 0
lastWriteTime = ticks_ms()
changesSinceLastWrite = 0

WRITE_INTERVAL = 10 * 60 * 1000  # 10 minutes
CHANGES_BEFORE_WRITE = 10

# Main loop
while True:
    currentTime = ticks_ms()
    
    entryReading = entryLoop.value()
    exitReading = exitLoop.value()
    
    # Handle entry detection
    if entryReading == 0 and (currentTime - lastEntryTime >= debounceDelay):
        sleep(0.05)
        if entryLoop.value() == 0:
            lastEntryTime = currentTime
            if vacantSlots > 0:
                vacantSlots -= 1
                totalEntry += 1
                printAvailableSlots()
                sendAvailableSlots(vacantSlots)
                sendNewUARTData(totalSlots, vacantSlots, totalEntry, totalExit)
                changesSinceLastWrite += 1
    
    # Handle exit detection
    if exitReading == 0 and (currentTime - lastExitTime >= debounceDelay):
        sleep(0.05)
        if exitLoop.value() == 0:
            lastExitTime = currentTime
            if vacantSlots < totalSlots:
                vacantSlots += 1
                totalExit += 1
                printAvailableSlots()
                sendAvailableSlots(vacantSlots)
                sendNewUARTData(totalSlots, vacantSlots, totalEntry, totalExit)
                changesSinceLastWrite += 1
    
    # Write to LittleFS if necessary
    if changesSinceLastWrite >= CHANGES_BEFORE_WRITE or ticks_diff(currentTime, lastWriteTime) >= WRITE_INTERVAL:
        save_data()
        lastWriteTime = currentTime
        changesSinceLastWrite = 0
    
    # Check if data is available on UART
    if uart.any():
        command = uart.read(1)
        if command == b'S':
            total_string = uart.read(3)
            vacant_string = uart.read(3)
            try:
                total = int(total_string)
                vacant = int(vacant_string)
                if total > 0 and 0 <= vacant <= total:
                    totalSlots = total
                    vacantSlots = vacant
                    save_data()
                    print("Total Parking Slots set to:", totalSlots)
                    print("Available Parking Slots set to:", vacantSlots)
                    sendAvailableSlots(vacantSlots)
            except ValueError:
                pass
    
    sleep(0.01)
